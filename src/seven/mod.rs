use crate::grid::Grid;

mod recursive;
use recursive::{RecurseState, recurse_to_depth};

pub fn parse_input(s: &str) {
    let mut grid = Grid::new(s);

    let Some((x, y)) = grid.find('S') else {
        panic!("could not find start location");
    };

    let mut state = RecurseState::new(3);

    recurse_to_depth(&mut grid, &mut state, x, y, 0);

    grid.print_grid();

    dbg!(state);
}

#[cfg(test)]
mod tests {
    use std::fs::read_to_string;

    use super::*;

    #[test]
    fn test_one() {
        let s = ".......S.......
...............
.......^.......
...............
......^.^......
...............
.....^.^.^.....
...............
....^.^...^....
...............
...^.^...^.^...
...............
..^...^.....^..
...............
.^.^.^.^.^...^.
...............";

        parse_input(s);
    }

    #[test]
    fn test_two() {
        let s = ".......S.......
...............
.......^.......
...............
......^.^......
...............
.....^.^.^.....
...............
....^.^...^....
...............
...............";

        parse_input(s);
    }

    #[test]
    fn test_input() {
        let s = read_to_string("src/seven/input.txt").expect("expected src/seven/input.txt");

        parse_input(&s);
    }
}
